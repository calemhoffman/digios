#include "HELIOS_LIB.h"
#include "TROOT.h"
#include "TBenchmark.h"
#include "TLorentzVector.h"
#include "TMath.h"
#include "TFile.h"
#include "TF1.h"
#include "TTree.h"
#include "TRandom.h"
#include <stdlib.h>
#include <vector>
#include <fstream>
#include <TObjArray.h>

//----------- usage 
// $root transfer.C+ | tee output.txt
// this will same the massage to output.txt

void transfer(){

   //================================================= User Setting
   //---- reaction
   int AA = 206, zA = 80;
   int Aa = 2,  za = 1;
   int Ab = 1,  zb = 1;
   
   //---- beam
   double KEAmean = 7.0; // MeV/u 
   double KEAsigma = 0; //KEAmean*0.001; // MeV/u , assume Guassian
   double thetaMean = 0.; // mrad 
   double thetaSigma = 0.; // mrad , assume Guassian due to small angle
   double xBeam = 0; // mm
   double yBeam = 0; // mm
   
   int numEvent = 1000000;
   
   //---- HELIOS detector geometry
   string heliosDetGeoFile = "detectorGeo.txt";
   double BField = 2.5; // T
   double BFieldTheta = 0.; // direction of B-field
   bool isCoincidentWithRecoil = false; 
   double eSigma = 0.005 ; // detector energy sigma MeV
   double zSigma = 0.010 ; // detector position sigma mm
   
   //---- excitation of Beam 
   int nExA = 1;
   double ExAList[nExA];
   ExAList[0] = 0.000; // MeV
   //ExAList[1] = 1.567;
    
   //---- excitation of recoil
   string excitationFile = "excitation_energies.txt"; //when no file, only ground state
   
   //---- save root file name
   TString saveFileName = "transfer.root";
   TString filename = "reaction.dat";
   
   //---- target
   bool isTargetScattering = false;
   double density = 0.913; // 0.913 g/cm3
   double targetThickness = 2./2. * 2.2e-4; // 2.2 um = 201 ug/cm2
   string stoppingPowerForA = "25Mg_in_CD2.txt"; // generated by SRIM
   string stoppingPowerForb = "1H_in_CD2.txt";
   string stoppingPowerForB = "26Mg_in_CD2.txt";
   
   //---- Auxiliary setting
   bool isDecay = true;
   bool isReDo = false; // redo calculation until detected. 
   
   //---- if basicConfig.txt exist, overide the reaction
   string basicConfig="basicReactionConfig.txt";
   ifstream cFile;
   cFile.open(basicConfig.c_str());
   bool isOverided = false;
   if( cFile.is_open() ){
      string line;
      int i = 0;
      while( cFile >> line){
         //printf("%d, %s \n", i,  line.c_str());
         if( line.substr(0,2) == "//" ) continue;
         if( i == 0 ) AA = atoi(line.c_str());
         if( i == 1 ) zA = atoi(line.c_str());
         if( i == 2 ) Aa = atoi(line.c_str());
         if( i == 3 ) za = atoi(line.c_str());
         if( i == 4 ) Ab = atoi(line.c_str());
         if( i == 5 ) zb = atoi(line.c_str());
         if( i == 6 ) BField = atof(line.c_str());
         if( i == 7 ) KEAmean = atof(line.c_str());
         if( i == 8 ) numEvent = atoi(line.c_str());
         if( i == 9 ) {
            if( line.compare("false") == 0 ) isDecay = false;
            if( line.compare("true") == 0 ) isDecay = true;
         }
         if( i == 10 ) {
            if( line.compare("false") == 0 ) isReDo = false;
            if( line.compare("true") == 0 ) isReDo = true;
         }
         if( i == 11 ) xBeam = atof(line.c_str());
         if( i == 12 ) yBeam = atof(line.c_str());
         i = i + 1;
      }
      cFile.close();
      isOverided = true;
   }
   
   //=============================================================
   //=============================================================
   //=============================================================
   //===== Set Reaction
   TransferReaction reaction;
   int AB = AA+Aa-Ab, zB = zA+za-zb;
   reaction.SetA(AA,zA);
   reaction.Seta(Aa,za);
   reaction.Setb(Ab,zb);
   reaction.SetB(AB,zB);
   reaction.SetIncidentEnergyAngle(KEAmean, 0, 0);
   reaction.CalReactionConstant();
   
   printf("===================================================\n");
   printf("=========== %27s ===========\n", reaction.GetReactionName().Data());
   printf("===================================================\n");
   if( isOverided )printf("----- overiding reaction from %s. \n", basicConfig.c_str());
   printf("         KE: %7.4f +- %5.4f MeV/u, dp/p = %5.2f %% \n", KEAmean, KEAsigma, KEAsigma/KEAmean * 50.);
   printf("      theta: %7.4f +- %5.4f MeV/u \n", thetaMean, thetaSigma);
   printf("offset(x,y): %7.4f, %7.4f mm \n", xBeam, yBeam);
   printf("   Q-value : %7.4f MeV \n", reaction.GetQValue() );
   printf("     Max Ex: %7.4f MeV \n", reaction.GetMaxExB() );
   printf("===================================================\n");
   
   //======== Set HELIOS
   printf("############################################## HELIOS configuration\n");   
   HELIOS helios;
   helios.OverrideMagneticFieldDirection(BFieldTheta);
   bool sethelios = helios.SetDetectorGeometry(heliosDetGeoFile);
   if( !sethelios){
		helios.OverrideMagneticField(BField);
		printf("======== B-field : %5.2f T, Theta : %6.2f deg\n", BField, BFieldTheta);
	}
   helios.SetCoincidentWithRecoil(isCoincidentWithRecoil);
   int mDet = helios.GetNumberOfDetectorsInSamePos();
   printf("========== energy resol.: %f MeV\n", eSigma);
   printf("=========== pos-Z resol.: %f mm \n", zSigma);
   double beta = reaction.GetReactionBeta() ;
   double gamma = reaction.GetReactionGamma();
   double mb = reaction.GetMass_b();
   double pCM = reaction.GetMomentumbCM();
   double q = TMath::Sqrt(mb*mb + pCM*pCM);
   double slope = 299.792458 * zb * helios.GetBField() / TMath::TwoPi() * beta / 1000.; // MeV/mm
   printf("====================== e-z slope : %f MeV/mm\n", slope);   
   double intercept = q/gamma - mb; // MeV
   printf("=== e-z intercept (ground state) : %f MeV\n", intercept); 
   
   //============ save reaction.dat
   FILE * paraOut;
   paraOut = fopen (filename.Data(), "w+");
   
   printf("=========== save reaction constants to %s \n", filename.Data());
   
   fprintf(paraOut, "%-15.4f  //%s\n", reaction.GetMass_b(), "mass_b");
   fprintf(paraOut, "%-15d  //%s\n", zb, "charge_b");
   fprintf(paraOut, "%-15.8f  //%s\n", reaction.GetReactionBeta(), "betaCM");
   fprintf(paraOut, "%-15.4f  //%s\n", reaction.GetCMTotalEnergy(), "Etot");
   fprintf(paraOut, "%-15.4f  //%s\n", reaction.GetMass_B(), "mass_B");
   fprintf(paraOut, "%-15.4f  //%s\n", slope/beta, "alpha=slope/beta");
    
   fflush(paraOut);
   fclose(paraOut);
   
   //==== Target scattering, only energy loss
   if(isTargetScattering) printf("############################################## Target Scattering\n");
   TargetScattering msA;
   TargetScattering msB;
   TargetScattering msb;

   if(isTargetScattering) printf("======== Target : (thickness : %6.2f um) x (density : %6.2f g/cm3) = %6.2f ug/cm2\n", 
                        targetThickness * 1e+4, 
                        density, 
                        targetThickness * density * 1e+6);  
            
   if( isTargetScattering ){
      msA.LoadStoppingPower(stoppingPowerForA);
      msb.LoadStoppingPower(stoppingPowerForb);
      msB.LoadStoppingPower(stoppingPowerForB);
   }
   
   //======= Decay of particle-B
   Decay decay;
   if(isDecay) decay.SetMotherDaugther(AB, zB, AB-1,zB); //neutron decay
   
   //======= loading excitation energy
   printf("############################################## excitation energies\n");
   vector<double> ExKnown;
   vector<double> y0; // intercept of e-z plot
   vector<double> kCM; // momentum of b in CM frame
   printf("----- loading excitation energy levels.");
   ifstream file;
   file.open(excitationFile.c_str());
   string isotopeName;
   if( file.is_open() ){
      string line;
      int i = 0;
      while( file >> line){
         //printf("%d, %s \n", i,  line.c_str());
         if( line.substr(0,2) == "//" ) continue;
         if( i == 0 ) isotopeName = line; 
         if ( i >= 1 ){
            ExKnown.push_back(atof(line.c_str()));
         }
         i = i + 1;
      }
      file.close();
      printf("... done.\n");
      printf("========== %s\n", isotopeName.c_str());
      int n = ExKnown.size();
      for(int i = 0; i < n ; i++){
         reaction.SetExB(ExKnown[i]);
         reaction.CalReactionConstant();
         kCM.push_back(reaction.GetMomentumbCM());
         y0.push_back(TMath::Sqrt(mb*mb + kCM[i]*kCM[i])/gamma - mb);
         if( isDecay ) {
            TLorentzVector temp(0,0,0,0);
            int decayID = decay.CalDecay(temp, ExKnown[i], 0);
            if( decayID == 1) {
               printf("%d, Ex: %6.2f MeV, y0: %4.2f MeV --> Decay. \n", i, ExKnown[i], y0[i]);
            }else{
               printf("%d, Ex: %6.2f MeV, y0: %4.2f MeV\n", i, ExKnown[i], y0[i]);
            }
         }else{
            printf("%d, Ex: %6.2f MeV, y0: %4.2f MeV \n", i, ExKnown[i], y0[i]);
         }
      }
   }else{
      printf("... fail ------> only ground state.\n");
      ExKnown.push_back(0.0);
      reaction.SetExB(ExKnown[0]);
      reaction.CalReactionConstant();
      kCM.push_back(reaction.GetMomentumbCM());
      y0.push_back(TMath::Sqrt(mb*mb + kCM[0]*kCM[0])/gamma - mb);
   }
   
   //====================== build tree
   TFile * saveFile = new TFile(saveFileName, "recreate");
   TTree * tree = new TTree("tree", "tree");
   
   double thetaCM;
   double thetab, phib, Tb;
   double thetaB, phiB, TB;
   
   int hit; // the output of Helios.CalHit
   double e, z, x, t, TbLoss;
   int loop, detID, detRowID;
   double dphi, rho; //rad of rotation, and radius
   int ExID;
   double Ex, KEA, KEAnew, theta, phi;
   double ExA;
   int ExAID;
   double recoilT;

   double rhoHit, rhoBHit; // rhoHit = radius of particle-b hit on z-pos of recoil detector
   double decayTheta; // the change of thetaB due to decay
   
   double xHit, yHit; //x, y positon of proton
   
   tree->Branch("hit", &hit, "hit/I");
   tree->Branch("thetab", &thetab, "thetab/D");
   tree->Branch("phib", &phib, "phib/D");
   tree->Branch("Tb", &Tb, "Tb/D");
   tree->Branch("thetaB", &thetaB, "thetaB/D");
   tree->Branch("phiB", &phiB, "phiB/D");
   tree->Branch("TB", &TB, "TB/D");
   tree->Branch("thetaCM", &thetaCM, "thetaCM/D");
   tree->Branch("e", &e, "e/D");
   tree->Branch("x", &x, "x/D");
   tree->Branch("z", &z, "z/D");
   tree->Branch("t", &t, "t/D");
   tree->Branch("recoilT", &recoilT, "recoilT/D");
   tree->Branch("TbLoss", &TbLoss, "TbLoss/D");
   tree->Branch("detID", &detID, "detID/I");
   tree->Branch("detRowID", &detRowID, "detRowID/I");
   tree->Branch("loop", &loop, "loop/I");
   tree->Branch("dphi", &dphi, "dphi/D");
   tree->Branch("rho", &rho, "rho/D");
   
   tree->Branch("ExID", &ExID, "ExID/I");
   tree->Branch("Ex", &Ex, "Ex/D");
   
   double ExCal, thetaCMCal;
   tree->Branch("ExCal", &ExCal, "ExCal/D");
   tree->Branch("thetaCMCal", &thetaCMCal, "thetaCMCal/D");
   
   tree->Branch("theta", &theta, "theta/D");
   tree->Branch("phi", &phi, "phi/D");
   tree->Branch("KEA", &KEA, "KEA/D");
   tree->Branch("KEAnew", &KEAnew, "KEAnew/D");
   tree->Branch("ExAID", &ExAID, "ExAID/I");
   tree->Branch("ExA", &ExA, "ExA/D");
   
   double mA, mB;
   tree->Branch("mA", &mA, "mA/D");
   tree->Branch("mB", &mB, "mB/D");
   tree->Branch("mb", &mb, "mb/D");

   tree->Branch("rhoHit", &rhoHit, "rhoHit/D");
   tree->Branch("rhoBHit", &rhoBHit, "rhoBHit/D");
   tree->Branch("decayTheta", &decayTheta, "decayTheta/D");
   
   tree->Branch("xHit", &xHit, "xHit/D");
   tree->Branch("yHit", &yHit, "yHit/D");

   double rxHit, ryHit;
   tree->Branch("rxHit", &rxHit, "rxHit/D");
   tree->Branch("ryHit", &ryHit, "ryHit/D");
   //double rxHit1, ryHit1;
   //tree->Branch("rxHit1", &rxHit1, "rxHit1/D");
   //tree->Branch("ryHit1", &ryHit1, "ryHit1/D");

   //double rxHit2, ryHit2;
   //tree->Branch("rxHit2", &rxHit2, "rxHit2/D");
   //tree->Branch("ryHit2", &ryHit2, "ryHit2/D");
   
   //double reactionP;
   //tree->Branch("reactionP", &reactionP, "reactionP/D");
   
   //======= function for e-z plot for ideal case
   printf("++++ generate functions and save to %s", saveFileName.Data());
   TObjArray * gList = new TObjArray();
   TF1* g0 = new TF1("g0", "TMath::Sqrt([0] + [1] * x*x) - [2]", -1000, 1000);
   g0->SetParameter(0, mb*mb);
   g0->SetParameter(1, TMath::Power(slope/beta,2));
   g0->SetParameter(2, mb);
   g0->SetNpx(1000);
   gList->Add(g0);
   //g0->Write();      
   printf("/");
   
   TF1 ** gx = new TF1*[50];
   TString name;
   for( int i = 1; i <= 50; i++){
      name.Form("g%d", i);     
      gx[i] = new TF1(name, "([0]*TMath::Sqrt([1]+[2]*x*x)+[5]*x)/([3]) - [4]", -1000, 1000);      
      double thetacm = i * TMath::DegToRad();
      double gS2 = TMath::Power(TMath::Sin(thetacm)*gamma,2);
      gx[i]->SetParameter(0, TMath::Cos(thetacm));
      gx[i]->SetParameter(1, mb*mb*(1-gS2));
      gx[i]->SetParameter(2, TMath::Power(slope/beta,2));
      gx[i]->SetParameter(3, 1-gS2);
      gx[i]->SetParameter(4, mb);
      gx[i]->SetParameter(5, -gS2*slope);
      gx[i]->SetNpx(1000);
      gList->Add(gx[i]);
      printf("/");
   }
   gList->Write("gList", TObject::kSingleKey);
   

   int n = ExKnown.size();
   TObjArray * fList = new TObjArray();
   TF1** f = new TF1*[n];
   for( int i = 0; i< n ; i++){
      name.Form("f%d", i);     
      f[i] = new TF1(name, "[0] + [1] * x", -1000, 1000);      
      f[i]->SetParameter(0, y0[i]);
      f[i]->SetParameter(1, slope);
      f[i]->SetNpx(1000);
      fList->Add(f[i]);
      printf(".");
   }
   fList->Write("fList", TObject::kSingleKey);
   
   //--- cal modified f
   TObjArray * fxList = new TObjArray();
   TGraph ** fx = new TGraph*[n];
   for( int j = 0 ; j < n; j++){
      double px[100];
      double py[100];
      double a = helios.GetDetectorA();
      double q = TMath::Sqrt(mb*mb + kCM[j] * kCM[j] );
      for(int i = 0; i < 100; i++){
      
         double thetacm = TMath::Pi()/TMath::Log(100) * (TMath::Log(100) - TMath::Log(100-i)) ;//using log scale, for more point in small angle.
         double temp = TMath::TwoPi() * slope / beta / kCM[j] * a / TMath::Sin(thetacm); 
         px[i] = beta /slope * (gamma * beta * q - gamma * kCM[j] * TMath::Cos(thetacm)) * (1 - TMath::ASin(temp)/TMath::TwoPi()) ;
         py[i] = gamma * q - mb - gamma * beta * kCM[j] * TMath::Cos(thetacm);   
      }
      
      fx[j] = new TGraph(100, px, py);
      name.Form("fx%d", j);
      fx[j]->SetName(name);
      fx[j]->SetLineColor(4);
      fxList->Add(fx[j]);
      printf(",");
   }
   fxList->Write("fxList", TObject::kSingleKey);
   
   //--- cal modified thetaCM vs z
   TObjArray * txList = new TObjArray();
   TGraph ** tx = new TGraph*[n];
   for( int j = 0 ; j < n; j++){
      double px[100];
      double py[100];
      double a = helios.GetDetectorA();
      double q = TMath::Sqrt(mb*mb + kCM[j] * kCM[j] );
      for(int i = 0; i < 100; i++){
      
         double thetacm = (i + 8.) * TMath::DegToRad();
         double temp = TMath::TwoPi() * slope / beta / kCM[j] * a / TMath::Sin(thetacm); 
         px[i] = beta /slope * (gamma * beta * q - gamma * kCM[j] * TMath::Cos(thetacm)) * (1 - TMath::ASin(temp)/TMath::TwoPi());
         py[i] = thetacm * TMath::RadToDeg();   
      }
      
      tx[j] = new TGraph(100, px, py);
      name.Form("tx%d", j);
      tx[j]->SetName(name);
      tx[j]->SetLineColor(4);
      txList->Add(tx[j]);
      //tx[j]->Write();
      printf("*");
   }
   txList->Write("txList", TObject::kSingleKey);
   printf("done!\n");
   
   //========timer
   TBenchmark clock;
   bool shown ;   
   clock.Reset();
   clock.Start("timer");
   shown = false;
   printf("############################################## generating %d events \n", numEvent);
   
   //====================================================== calculate 
   int count = 0;
   for( int i = 0; i < numEvent; i++){
      bool redoFlag = true;
      if( !isReDo ) redoFlag = false;
      do{
      
         //==== Set Ex of A
         ExAID = gRandom->Integer(nExA);
         ExA = ExAList[ExAID];
         reaction.SetExA(ExA);
         
         //==== Set Ex of B
         ExID = gRandom->Integer(ExKnown.size());
         Ex = ExKnown[ExID]; 
         reaction.SetExB(Ex);
         
         //==== Set incident beam
         if( KEAsigma == 0 ){
            KEA = KEAmean;
         }else{
            KEA = gRandom->Gaus(KEAmean, KEAsigma);
         }
         if( thetaSigma == 0 ){
            theta = thetaMean;
         }else{
            theta = gRandom->Gaus(thetaMean, thetaSigma);
         }
         //for taregt scattering
         reaction.SetIncidentEnergyAngle(KEA, theta, 0.);
         reaction.CalReactionConstant();
         TLorentzVector PA = reaction.GetPA();            
         
         double depth = 0;
         if( isTargetScattering ){
            //==== Target scattering, only energy loss
            depth = targetThickness * gRandom->Rndm();
            msA.SetTarget(density, depth); 
            TLorentzVector PAnew = msA.Scattering(PA);
            KEAnew = msA.GetKE()/AA;
            reaction.SetIncidentEnergyAngle(KEAnew, theta, phi);
         }
         
         //==== Calculate reaction
         thetaCM = TMath::ACos(2 * gRandom->Rndm() - 1) ; 
         //double phiCM = TMath::TwoPi() / mDet * ( gRandom->Rndm() - 0.5); // reduce the range of phiCM for faster calculation
         double phiCM = TMath::TwoPi() * gRandom->Rndm(); 
         
         TLorentzVector * output = reaction.Event(thetaCM, phiCM);
         
         TLorentzVector Pb = output[2];
         TLorentzVector PB = output[3];
         
         //==== Calculate energy loss of scattered and recoil in target
         if( isTargetScattering ){
            if( Pb.Theta() < TMath::PiOver2() ){
               msb.SetTarget(density, targetThickness - depth);
            }else{
               msb.SetTarget(density, depth);
            }
            Pb = msb.Scattering(Pb);
            TbLoss = msb.GetKELoss();
            msB.SetTarget(density, targetThickness - depth);
            PB = msB.Scattering(PB);
         }else{
            TbLoss = 0;
         }
         
         //======= Decay of particle-B
         if( isDecay){
            int decayID = decay.CalDecay(PB, Ex, 0); // decay to ground state
            if( decayID == 1 ){
               PB = decay.GetDaugther_D();
               decayTheta = decay.GetAngleChange();
            }else{
               decayTheta = TMath::QuietNaN();
            }
         }
         
         //################################### tree branches
         //===== reaction
         thetab = Pb.Theta() * TMath::RadToDeg();
         thetaB = PB.Theta() * TMath::RadToDeg();
      
         Tb = Pb.E() - Pb.M();
         TB = PB.E() - PB.M();
         
         phib = Pb.Phi() * TMath::RadToDeg();
         phiB = PB.Phi() * TMath::RadToDeg();
         
         //reactionP = reaction.GetMomentumbCM();
         //Qvalue = reaction.GetQValue();
         mA = reaction.GetMass_A();
         mB = reaction.GetMass_B();
         mb = reaction.GetMass_b();
         
         //==== Helios
         hit = helios.CalHit(Pb, zb, PB, zB, xBeam, yBeam);
         
         e = helios.GetEnergy() + gRandom->Gaus(0, eSigma);
         z = helios.GetZ() ; 
         x = helios.GetX() + gRandom->Gaus(0, zSigma);
         t = helios.GetTime();
         loop = helios.GetLoop();
         detID = helios.GetDetID();
         detRowID = helios.GetDetRowID();
         dphi = helios.GetdPhi();
         rho = helios.GetRho();
         rhoHit = helios.GetRhoHit();
         //rhoHit = helios.GetR(120.4);
         rhoBHit = helios.GetRecoilRhoHit();
         //rhoBHit = helios.GetR(134.8);
         xHit = helios.GetXPos(z);
         yHit = helios.GetYPos(z);
         //xHit = helios.GetXPos(125.7);
         //yHit = helios.GetYPos(125.7);
         z += gRandom->Gaus(0, zSigma);
         
         recoilT = helios.GetRecoilTime();
         rxHit = helios.GetRecoilXHit();
         ryHit = helios.GetRecoilYHit();
         //rxHit1 = helios.GetRecoilXPos(1463.7+100);
         //ryHit1 = helios.GetRecoilYPos(1463.7+100);
         //rxHit2 = helios.GetRecoilXPos(1463.7+200);
         //ryHit2 = helios.GetRecoilYPos(1463.7+200);
         
         reaction.CalExThetaCM(e, z, BField, helios.GetDetectorA());
         ExCal = reaction.GetEx();
         thetaCMCal = reaction.GetThetaCM();
         
         //change thetaCM into deg
         thetaCM = thetaCM * TMath::RadToDeg();
         
         if( hit == 1) {
            count ++;
         }
         
         if( isReDo ){
            if( hit == 1) {
               redoFlag = false;
            }else{
               redoFlag = true;
               //printf("%d, %2d, thetaCM : %f, theta : %f, z0: %f \n", i, hit, thetaCM * TMath::RadToDeg(), thetab, helios.GetZ0());
            }
         }else{
            redoFlag = false;
         }
         
      }while( redoFlag );
      tree->Fill();
      
      //#################################################################### Timer  
      clock.Stop("timer");
      Double_t time = clock.GetRealTime("timer");
      clock.Start("timer");
      
      if ( !shown ) {
         if (fmod(time, 10) < 1 ){
            printf( "%10d[%2d%%]| %8.2f sec | expect: %5.1f min \n", i, TMath::Nint((i+1)*100./numEvent), time , numEvent*time/(i+1)/60);
            shown = 1;
         }
      }else{
         if (fmod(time, 10) > 9 ){
            shown = 0;
         }
      }
   }
   
   saveFile->Write();
   saveFile->Close();
   
   printf("=============== done. saved as %s. count(hit==1) : %d\n", saveFileName.Data(), count);
   gROOT->ProcessLine(".q");
}
